#!/usr/bin/env python3
# setup_config.py - Script de configuration automatique LinkedBoost
import os
import sys
import shutil
from pathlib import Path

def create_directories():
    """Cr√©e la structure de dossiers n√©cessaire"""
    directories = [
        'data',
        'logs', 
        'cache',
        'models',
        'scrapers',
        'templates/admin',
        'static/css',
        'static/js',
        'tests'
    ]
    
    print("üìÅ Cr√©ation de la structure de dossiers...")
    for directory in directories:
        Path(directory).mkdir(parents=True, exist_ok=True)
        print(f"   ‚úÖ {directory}")

def setup_env_file():
    """Configure le fichier .env"""
    env_file = Path('.env')
    env_template = Path('.env.template')
    
    if env_file.exists():
        print("‚ö†Ô∏è  Le fichier .env existe d√©j√†")
        response = input("Voulez-vous le remplacer ? (y/N): ")
        if response.lower() != 'y':
            print("   üìù Fichier .env conserv√©")
            return
    
    if env_template.exists():
        shutil.copy('.env.template', '.env')
        print("‚úÖ Fichier .env cr√©√© depuis le template")
    else:
        # Cr√©ation d'un .env minimal
        env_content = """# Configuration LinkedBoost - G√©n√©r√©e automatiquement
FLASK_ENV=development
FLASK_DEBUG=True
SECRET_KEY=linkedboost-dev-key-change-in-production

# Ollama
OLLAMA_BASE_URL=http://localhost:11434
OLLAMA_MODEL=mistral:latest

# Scraping
SCRAPING_ENABLED=True
SELENIUM_HEADLESS=True
REQUEST_DELAY=2.0
ENABLED_SCRAPERS=wttj

# Base de donn√©es
DATABASE_URL=sqlite:///data/linkedboost.db
"""
        with open('.env', 'w') as f:
            f.write(env_content)
        print("‚úÖ Fichier .env minimal cr√©√©")

def check_dependencies():
    """V√©rifie les d√©pendances Python"""
    print("\nüì¶ V√©rification des d√©pendances...")
    
    # D√©pendances critiques
    critical_deps = {
        'flask': 'Flask',
        'requests': 'requests',
        'python-dotenv': 'dotenv',
        'beautifulsoup4': 'bs4'
    }
    
    # D√©pendances optionnelles
    optional_deps = {
        'selenium': 'selenium',
        'pandas': 'pandas', 
        'sklearn': 'scikit-learn',
        'sentence-transformers': 'sentence_transformers'
    }
    
    missing_critical = []
    missing_optional = []
    
    for pkg_name, import_name in critical_deps.items():
        try:
            __import__(import_name.replace('-', '_'))
            print(f"   ‚úÖ {pkg_name}")
        except ImportError:
            print(f"   ‚ùå {pkg_name} MANQUANT")
            missing_critical.append(pkg_name)
    
    for pkg_name, import_name in optional_deps.items():
        try:
            __import__(import_name.replace('-', '_'))
            print(f"   ‚úÖ {pkg_name} (optionnel)")
        except ImportError:
            print(f"   ‚ö†Ô∏è  {pkg_name} (optionnel)")
            missing_optional.append(pkg_name)
    
    if missing_critical:
        print(f"\n‚ùå D√©pendances critiques manquantes: {', '.join(missing_critical)}")
        print("   Installation: pip install " + ' '.join(missing_critical))
        return False
    
    if missing_optional:
        print(f"\nüí° D√©pendances optionnelles manquantes: {', '.join(missing_optional)}")
        print("   Pour le scraping complet: pip install selenium webdriver-manager")
        print("   Pour les embeddings: pip install sentence-transformers")
    
    return True

def test_ollama_connection():
    """Teste la connexion √† Ollama"""
    print("\nü§ñ Test de connexion √† Ollama...")
    
    try:
        import requests
        from config import Config
        
        response = requests.get(f"{Config.OLLAMA_BASE_URL}/api/tags", timeout=5)
        if response.status_code == 200:
            models = response.json().get('models', [])
            print(f"   ‚úÖ Ollama connect√© ({len(models)} mod√®les disponibles)")
            
            # V√©rifier si Mistral est disponible
            model_names = [m.get('name', '') for m in models]
            if any('mistral' in name for name in model_names):
                print("   ‚úÖ Mod√®le Mistral disponible")
            else:
                print("   ‚ö†Ô∏è  Mod√®le Mistral non trouv√©")
                print("   Installation: ollama pull mistral:latest")
            
            return True
        else:
            print(f"   ‚ùå Erreur HTTP {response.status_code}")
            return False
            
    except ImportError:
        print("   ‚ùå Module 'requests' manquant")
        return False
    except Exception as e:
        print(f"   ‚ùå Erreur connexion: {e}")
        print("   üí° D√©marrez Ollama avec: ollama serve")
        return False

def test_selenium_setup():
    """Teste la configuration Selenium"""
    print("\nüåê Test de configuration Selenium...")
    
    try:
        from selenium import webdriver
        from selenium.webdriver.chrome.options import Options
        
        options = Options()
        options.add_argument('--headless')
        options.add_argument('--no-sandbox')
        options.add_argument('--disable-dev-shm-usage')
        
        driver = webdriver.Chrome(options=options)
        driver.get('https://www.google.com')
        title = driver.title
        driver.quit()
        
        print(f"   ‚úÖ Selenium fonctionnel (test√© sur: {title[:30]}...)")
        return True
        
    except ImportError:
        print("   ‚ö†Ô∏è  Selenium non install√©")
        print("   Installation: pip install selenium webdriver-manager")
        return False
    except Exception as e:
        print(f"   ‚ùå Erreur Selenium: {e}")
        print("   üí° Installez Chrome et ChromeDriver")
        return False

def create_init_files():
    """Cr√©e les fichiers __init__.py manquants"""
    print("\nüìÑ Cr√©ation des fichiers d'initialisation...")
    
    init_files = [
        'models/__init__.py',
        'scrapers/__init__.py'
    ]
    
    for init_file in init_files:
        Path(init_file).touch()
        print(f"   ‚úÖ {init_file}")

def validate_config():
    """Valide la configuration compl√®te"""
    print("\nüîç Validation de la configuration...")
    
    try:
        from config import Config
        
        validation = Config.validate_config()
        
        if validation['valid']:
            print("   ‚úÖ Configuration valide")
        else:
            print("   ‚ùå Erreurs de configuration:")
            for error in validation['errors']:
                print(f"      - {error}")
        
        if validation['warnings']:
            print("   ‚ö†Ô∏è  Avertissements:")
            for warning in validation['warnings']:
                print(f"      - {warning}")
        
        # Afficher le r√©sum√©
        summary = Config.get_config_summary()
        print(f"\nüìä R√©sum√© de configuration:")
        print(f"   Environment: {summary['environment']}")
        print(f"   Mod√®le Ollama: {summary['ollama_model']}")
        print(f"   Scraping: {'‚úÖ' if summary['scraping_enabled'] else '‚ùå'}")
        print(f"   Scrapers: {', '.join(summary['enabled_scrapers'])}")
        print(f"   M√©thode recherche: {summary['search_method']}")
        
        return validation['valid']
        
    except ImportError as e:
        print(f"   ‚ùå Erreur import config: {e}")
        return False
    except Exception as e:
        print(f"   ‚ùå Erreur validation: {e}")
        return False

def generate_test_script():
    """G√©n√®re un script de test complet"""
    test_script = """#!/usr/bin/env python3
# test_linkedboost.py - Script de test complet
import asyncio
import sys
import os

# Ajouter le r√©pertoire courant au path
sys.path.insert(0, os.getcwd())

async def test_full_system():
    \"\"\"Test complet du syst√®me LinkedBoost\"\"\"
    print("üöÄ Test complet de LinkedBoost")
    print("=" * 50)
    
    errors = []
    
    # 1. Test de la configuration
    print("\\n1Ô∏è‚É£ Test de configuration...")
    try:
        from config import Config
        validation = Config.validate_config()
        if validation['valid']:
            print("   ‚úÖ Configuration OK")
        else:
            print("   ‚ùå Erreurs de configuration")
            errors.extend(validation['errors'])
    except Exception as e:
        print(f"   ‚ùå Erreur config: {e}")
        errors.append(str(e))
    
    # 2. Test Ollama
    print("\\n2Ô∏è‚É£ Test Ollama...")
    try:
        from models.ai_generator import LinkedBoostAI
        ai = LinkedBoostAI()
        if ai.is_available():
            print("   ‚úÖ Ollama connect√©")
            
            # Test de g√©n√©ration simple
            message = ai.generate_linkedin_message(
                message_type="connection",
                recipient_name="Test User",
                context="Test de configuration"
            )
            if message:
                print("   ‚úÖ G√©n√©ration IA fonctionnelle")
            else:
                print("   ‚ö†Ô∏è  G√©n√©ration IA retourne vide")
        else:
            print("   ‚ùå Ollama non disponible")
            errors.append("Ollama non connect√©")
    except Exception as e:
        print(f"   ‚ùå Erreur Ollama: {e}")
        errors.append(str(e))
    
    # 3. Test scraping
    print("\\n3Ô∏è‚É£ Test scraping...")
    try:
        from models.scraper import ScrapingOrchestrator
        orchestrator = ScrapingOrchestrator()
        
        if orchestrator.scrapers:
            print(f"   ‚úÖ Scrapers disponibles: {list(orchestrator.scrapers.keys())}")
            
            # Test de scraping (limit√©)
            stats = await orchestrator.run_full_scrape(['wttj'])
            jobs_count = stats.get('total_jobs', 0)
            print(f"   ‚úÖ Scraping test√©: {jobs_count} offres")
            
            if stats.get('selenium_available'):
                print("   ‚úÖ Selenium activ√©")
            else:
                print("   ‚ö†Ô∏è  Mode simulation (Selenium non disponible)")
        else:
            print("   ‚ùå Aucun scraper disponible")
            errors.append("Pas de scrapers")
    except Exception as e:
        print(f"   ‚ùå Erreur scraping: {e}")
        errors.append(str(e))
    
    # 4. Test base de connaissances
    print("\\n4Ô∏è‚É£ Test base de connaissances...")
    try:
        from models.knowledge_base import KnowledgeBase
        kb = KnowledgeBase()
        stats = kb.get_stats()
        
        print(f"   ‚úÖ Base de donn√©es: {stats.get('total_jobs', 0)} offres")
        print(f"   ‚úÖ M√©thode recherche: {stats.get('search_method', 'unknown')}")
        
        # Test de recherche
        results = await kb.search_jobs("d√©veloppeur python", limit=3)
        print(f"   ‚úÖ Recherche test√©e: {len(results)} r√©sultats")
        
    except Exception as e:
        print(f"   ‚ùå Erreur base de connaissances: {e}")
        errors.append(str(e))
    
    # 5. R√©sum√©
    print("\\n" + "=" * 50)
    if not errors:
        print("üéâ TOUS LES TESTS R√âUSSIS!")
        print("\\n‚úÖ LinkedBoost est pr√™t √† √™tre utilis√©")
        print("\\nüåê Lancez l'application avec: python app.py")
        print("üì± Interface admin: http://localhost:5000/admin")
    else:
        print("‚ùå ERREURS D√âTECT√âES:")
        for i, error in enumerate(errors, 1):
            print(f"   {i}. {error}")
        print("\\nüí° Consultez la documentation pour r√©soudre ces erreurs")
    
    return len(errors) == 0

if __name__ == "__main__":
    asyncio.run(test_full_system())
"""
    
    with open('test_linkedboost.py', 'w', encoding='utf-8') as f:
        f.write(test_script)
    
    print("   ‚úÖ Script de test cr√©√©: test_linkedboost.py")

def create_run_script():
    """Cr√©e un script de lancement optimis√©"""
    
    # Script pour Unix/Linux/Mac
    run_script_unix = """#!/bin/bash
# run_linkedboost.sh - Script de lancement LinkedBoost

echo "üöÄ D√©marrage de LinkedBoost"
echo "=========================="

# V√©rifier l'environnement virtuel
if [[ "$VIRTUAL_ENV" == "" ]]; then
    echo "‚ö†Ô∏è  Aucun environnement virtuel d√©tect√©"
    echo "üí° Recommand√©: source venv/bin/activate"
fi

# V√©rifier Ollama
echo "ü§ñ V√©rification d'Ollama..."
if ! curl -s http://localhost:11434/api/tags > /dev/null; then
    echo "‚ùå Ollama non disponible sur localhost:11434"
    echo "üí° D√©marrez Ollama avec: ollama serve"
    echo "üí° Installez le mod√®le: ollama pull mistral:latest"
    exit 1
else
    echo "‚úÖ Ollama connect√©"
fi

# Cr√©er les dossiers n√©cessaires
mkdir -p data logs cache

# D√©marrer l'application
echo "üåê D√©marrage de l'application..."
python app.py

echo "üëã LinkedBoost arr√™t√©"
"""
    
    # Script pour Windows
    run_script_windows = """@echo off
REM run_linkedboost.bat - Script de lancement LinkedBoost pour Windows

echo üöÄ D√©marrage de LinkedBoost
echo ==========================

REM V√©rifier l'environnement virtuel
if "%VIRTUAL_ENV%"=="" (
    echo ‚ö†Ô∏è  Aucun environnement virtuel d√©tect√©
    echo üí° Recommand√©: venv\\Scripts\\activate
)

REM Cr√©er les dossiers n√©cessaires
if not exist "data" mkdir data
if not exist "logs" mkdir logs
if not exist "cache" mkdir cache

REM V√©rifier Ollama (simple)
echo ü§ñ V√©rification d'Ollama...
curl -s http://localhost:11434/api/tags >nul 2>&1
if errorlevel 1 (
    echo ‚ùå Ollama non disponible sur localhost:11434
    echo üí° D√©marrez Ollama avec: ollama serve
    echo üí° Installez le mod√®le: ollama pull mistral:latest
    pause
    exit /b 1
) else (
    echo ‚úÖ Ollama connect√©
)

REM D√©marrer l'application
echo üåê D√©marrage de l'application...
python app.py

echo üëã LinkedBoost arr√™t√©
pause
"""
    
    # Cr√©er les scripts
    with open('run_linkedboost.sh', 'w', encoding='utf-8') as f:
        f.write(run_script_unix)
    
    with open('run_linkedboost.bat', 'w', encoding='utf-8') as f:
        f.write(run_script_windows)
    
    # Rendre le script Unix ex√©cutable
    try:
        os.chmod('run_linkedboost.sh', 0o755)
    except:
        pass
    
    print("   ‚úÖ Scripts de lancement cr√©√©s")
    print("      - run_linkedboost.sh (Unix/Linux/Mac)")
    print("      - run_linkedboost.bat (Windows)")

def create_development_helpers():
    """Cr√©e des utilitaires pour le d√©veloppement"""
    print("\nüõ†Ô∏è  Cr√©ation des utilitaires de d√©veloppement...")
    
    # Script de d√©veloppement
    dev_script = """#!/usr/bin/env python3
# dev.py - Utilitaires de d√©veloppement pour LinkedBoost

import os
import subprocess
import sys
import time

def run_command(cmd, description):
    \"\"\"Ex√©cute une commande avec affichage\"\"\"
    print(f"üîÑ {description}...")
    try:
        result = subprocess.run(cmd, shell=True, check=True, capture_output=True, text=True)
        print(f"‚úÖ {description} termin√©")
        return True
    except subprocess.CalledProcessError as e:
        print(f"‚ùå Erreur {description}: {e}")
        if e.stdout:
            print("STDOUT:", e.stdout)
        if e.stderr:
            print("STDERR:", e.stderr)
        return False

def setup_dev_environment():
    \"\"\"Configure l'environnement de d√©veloppement\"\"\"
    print("üîß Configuration environnement de d√©veloppement")
    
    # Installer les d√©pendances de dev
    dev_packages = [
        "black",  # Formatage code
        "flake8", # Linting
        "pytest", # Tests
        "pytest-flask", # Tests Flask
        "python-dotenv[cli]" # CLI dotenv
    ]
    
    for package in dev_packages:
        run_command(f"pip install {package}", f"Installation {package}")

def format_code():
    \"\"\"Formate le code avec Black\"\"\"
    print("üé® Formatage du code...")
    run_command("black .", "Formatage Black")
    run_command("flake8 . --max-line-length=88 --extend-ignore=E203,W503", "V√©rification Flake8")

def run_tests():
    \"\"\"Lance les tests\"\"\"
    print("üß™ Lancement des tests...")
    run_command("python test_linkedboost.py", "Tests syst√®me")
    
    if os.path.exists("tests/"):
        run_command("pytest tests/", "Tests unitaires")

def clean_project():
    \"\"\"Nettoie le projet\"\"\"
    print("üßπ Nettoyage du projet...")
    
    # Supprimer les fichiers Python compil√©s
    run_command("find . -name '*.pyc' -delete", "Suppression .pyc")
    run_command("find . -name '__pycache__' -type d -exec rm -rf {} +", "Suppression __pycache__")
    
    # Nettoyer les logs anciens
    if os.path.exists("logs/"):
        run_command("find logs/ -name '*.log' -mtime +7 -delete", "Nettoyage logs anciens")

def backup_data():
    \"\"\"Sauvegarde les donn√©es\"\"\"
    timestamp = time.strftime("%Y%m%d_%H%M%S")
    backup_dir = f"backup_{timestamp}"
    
    print(f"üíæ Sauvegarde dans {backup_dir}...")
    os.makedirs(backup_dir, exist_ok=True)
    
    # Sauvegarder les donn√©es importantes
    if os.path.exists("data/"):
        run_command(f"cp -r data/ {backup_dir}/", "Sauvegarde donn√©es")
    
    if os.path.exists(".env"):
        run_command(f"cp .env {backup_dir}/", "Sauvegarde configuration")

def main():
    if len(sys.argv) < 2:
        print("üîß Utilitaires de d√©veloppement LinkedBoost")
        print("Usage: python dev.py <commande>")
        print("\\nCommandes disponibles:")
        print("  setup     - Configure l'environnement de dev")
        print("  format    - Formate le code")
        print("  test      - Lance les tests")
        print("  clean     - Nettoie le projet") 
        print("  backup    - Sauvegarde les donn√©es")
        return
    
    command = sys.argv[1]
    
    if command == "setup":
        setup_dev_environment()
    elif command == "format":
        format_code()
    elif command == "test":
        run_tests()
    elif command == "clean":
        clean_project()
    elif command == "backup":
        backup_data()
    else:
        print(f"‚ùå Commande inconnue: {command}")

if __name__ == "__main__":
    main()
"""
    
    with open('dev.py', 'w', encoding='utf-8') as f:
        f.write(dev_script)
    
    try:
        os.chmod('dev.py', 0o755)
    except:
        pass
    
    print("   ‚úÖ dev.py cr√©√© (utilitaires d√©veloppement)")

def create_documentation():
    """Cr√©e la documentation de base"""
    print("\nüìö Cr√©ation de la documentation...")
    
    # README.md
    readme_content = """# LinkedBoost - Assistant IA pour LinkedIn

## üéØ Description
LinkedBoost est un assistant IA complet pour optimiser votre pr√©sence LinkedIn et automatiser la g√©n√©ration de contenu professionnel.

## üöÄ Installation rapide
```bash
# Configuration automatique
python setup_config.py

# Installation des d√©pendances
pip install -r requirements.txt

# Test du syst√®me
python test_linkedboost.py

# Lancement
python app.py
```

## üåê Acc√®s
- **Application principale** : http://localhost:5000
- **Interface d'administration** : http://localhost:5000/admin
- **API de statut** : http://localhost:5000/api/status

## ‚ú® Fonctionnalit√©s
- ü§ñ **G√©n√©ration IA** de messages LinkedIn, lettres de motivation, emails
- üìä **Analyse de profils** LinkedIn avec recommandations
- üï∑Ô∏è **Scraping automatique** d'offres d'emploi (WTTJ, Indeed, LinkedIn)
- üîç **Recherche s√©mantique** dans les offres collect√©es
- üìà **Analytics march√©** en temps r√©el
- üéõÔ∏è **Interface d'administration** compl√®te

## üìã Pr√©requis
- Python 3.8+
- Ollama install√© (`ollama serve`)
- Mod√®le Mistral (`ollama pull mistral:latest`)
- Chrome (pour le scraping Selenium)

## üîß Configuration
Voir le fichier `.env.template` pour toutes les options de configuration.

## üìñ Documentation compl√®te
Consultez `INSTALL.md` pour le guide d'installation d√©taill√©.

## üÜò Support
- Tests : `python test_linkedboost.py`
- Logs : `tail -f logs/linkedboost.log`
- Configuration : `python setup_config.py`
"""
    
    with open('README.md', 'w', encoding='utf-8') as f:
        f.write(readme_content)
    
    print("   ‚úÖ README.md cr√©√©")
    
    # .gitignore
    gitignore_content = """# LinkedBoost .gitignore

# Environnement Python
venv/
env/
__pycache__/
*.pyc
*.pyo
*.pyd
.Python

# Configuration sensible
.env
config_local.py

# Donn√©es et cache
data/
logs/
cache/
*.db
*.sqlite
*.sqlite3

# Selenium
geckodriver.log
chromedriver.log

# Embeddings et mod√®les
embeddings/
models_cache/
chroma_db/

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Backup
*.bak
*.backup
backup/

# Logs
*.log
"""
    
    with open('.gitignore', 'w', encoding='utf-8') as f:
        f.write(gitignore_content)
    
    print("   ‚úÖ .gitignore cr√©√©")

def show_final_summary():
    """Affiche le r√©sum√© final avec les prochaines √©tapes"""
    print("\n" + "üéâ" + "=" * 48 + "üéâ")
    print("         CONFIGURATION LINKEDBOOST TERMIN√âE")
    print("üéâ" + "=" * 48 + "üéâ")
    
    print("\nüìÅ Structure cr√©√©e:")
    print("   ‚îú‚îÄ‚îÄ config.py                 (Configuration principale)")
    print("   ‚îú‚îÄ‚îÄ .env                      (Variables d'environnement)")
    print("   ‚îú‚îÄ‚îÄ requirements.txt          (D√©pendances Python)")
    print("   ‚îú‚îÄ‚îÄ models/__init__.py        (Modules IA/scraping)")
    print("   ‚îú‚îÄ‚îÄ scrapers/__init__.py      (Modules de scraping)")
    print("   ‚îú‚îÄ‚îÄ data/                     (Base de donn√©es)")
    print("   ‚îú‚îÄ‚îÄ logs/                     (Fichiers de logs)")
    print("   ‚îú‚îÄ‚îÄ cache/                    (Cache application)")
    print("   ‚îî‚îÄ‚îÄ templates/admin/          (Interface admin)")
    
    print("\nüöÄ Scripts cr√©√©s:")
    print("   ‚îú‚îÄ‚îÄ test_linkedboost.py      (Test complet du syst√®me)")
    print("   ‚îú‚îÄ‚îÄ run_linkedboost.sh       (Lancement Unix/Linux/Mac)")
    print("   ‚îú‚îÄ‚îÄ run_linkedboost.bat      (Lancement Windows)")
    print("   ‚îú‚îÄ‚îÄ dev.py                   (Utilitaires d√©veloppement)")
    print("   ‚îú‚îÄ‚îÄ README.md                (Documentation principale)")
    print("   ‚îî‚îÄ‚îÄ .gitignore               (Configuration Git)")
    
    print("\nüìã PROCHAINES √âTAPES:")
    print("   1Ô∏è‚É£  pip install -r requirements.txt")
    print("   2Ô∏è‚É£  √âditez .env selon vos besoins")
    print("   3Ô∏è‚É£  python test_linkedboost.py")
    print("   4Ô∏è‚É£  python app.py")
    print("   5Ô∏è‚É£  Acc√©dez √† http://localhost:5000/admin")
    
    print("\nüîß COMMANDES UTILES:")
    print("   ‚Ä¢ Test syst√®me:     python test_linkedboost.py")
    print("   ‚Ä¢ Validation:       python -c \"from config import Config; print(Config.validate_config())\"")
    print("   ‚Ä¢ Lancement:        ./run_linkedboost.sh (ou python app.py)")
    print("   ‚Ä¢ D√©veloppement:    python dev.py setup")
    
    print("\nüÜò EN CAS DE PROBL√àME:")
    print("   ‚Ä¢ Consultez INSTALL.md pour le guide d√©taill√©")
    print("   ‚Ä¢ V√©rifiez les logs: tail -f logs/*.log") 
    print("   ‚Ä¢ Relancez setup:   python setup_config.py")
    
    print("\nüåü LinkedBoost est pr√™t √† √™tre utilis√© !")
    print("   Interface admin: http://localhost:5000/admin")
    print("   Documentation:   README.md et INSTALL.md")

def main():
    """Fonction principale de configuration"""
    print("üîß Configuration automatique de LinkedBoost")
    print("=" * 50)
    
    success = True
    
    # 1. Cr√©er la structure
    create_directories()
    create_init_files()
    
    # 2. Configuration
    setup_env_file()
    
    # 3. V√©rifications
    if not check_dependencies():
        success = False
    
    if not test_ollama_connection():
        success = False
    
    test_selenium_setup()  # Non bloquant
    
    # 4. Validation
    if not validate_config():
        success = False
    
    # 5. Scripts utilitaires
    print("\nüõ†Ô∏è  Cr√©ation des scripts utilitaires...")
    generate_test_script()
    create_run_script()
    create_development_helpers()
    
    # 6. Documentation
    create_documentation()
    
    # 7. R√©sum√© final
    if success:
        show_final_summary()
    else:
        print("\n‚ö†Ô∏è  CONFIGURATION TERMIN√âE AVEC DES AVERTISSEMENTS")
        print("\nüîß R√©solvez les erreurs ci-dessus puis relancez:")
        print("   python setup_config.py")

if __name__ == "__main__":
    main()